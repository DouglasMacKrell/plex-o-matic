name: Test & Quality Check

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.8", "3.9", "3.10", "3.11"]
      fail-fast: false  # Continue with other versions even if one fails

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        # Install explicit dependencies for debugging
        pip install pytest pytest-cov pytest-mock black ruff mypy typing_extensions
        # Install package in development mode using setup.py
        pip install -e ".[test,dev]"
        # Make sure setuptools is up to date
        pip install --upgrade setuptools

    - name: Verify package installation
      run: |
        echo "Python version:"
        python --version
        echo "Working directory:"
        pwd
        echo "Installed package info:"
        pip show plex-o-matic || echo "Package not installed correctly"
        echo "Plexomatic import path:"
        python -c "import plexomatic; print(plexomatic.__file__)" || echo "Failed to import plexomatic"
        echo "SQLite version:"
        python -c "import sqlite3; print(f'SQLite version: {sqlite3.sqlite_version}')"
        echo "Sys.path:"
        python -c "import sys; print('\n'.join(sys.path))"
        echo "Package structure:"
        find plexomatic -type f -name "*.py" | sort
        echo "Test structure:"
        find tests -type f -name "*.py" | sort

    - name: Debug Python import system
      run: |
        cat > debug_pythonpath.py << 'EOF'
        import sys
        import os
        import importlib
        import inspect

        print("Current working directory:", os.getcwd())
        print("\nPYTHONPATH:", os.environ.get("PYTHONPATH", "Not set"))
        print("\nSystem path:")
        for i, path in enumerate(sys.path):
            print(f"{i}: {path}")

        def check_module(name):
            print(f"\nChecking module: {name}")
            try:
                module = importlib.import_module(name)
                print(f"  Success! Module loaded from: {getattr(module, '__file__', 'Unknown')}")
                return True
            except Exception as e:
                print(f"  Failed: {e}")
                return False

        modules = [
            'plexomatic',
            'tests',
            'pytest',
        ]

        for module in modules:
            check_module(module)
        EOF

        # Execute the debug script
        python debug_pythonpath.py

    - name: Test direct import
      run: |
        echo "Checking if test modules can import plexomatic directly:"
        python -c "import sys; print(sys.path); import plexomatic; print('Success!')"

        echo "Checking if tests package can be imported:"
        python -c "import sys; print(sys.path); import tests; print('Success!')"

    - name: Check formatting with black
      run: |
        black --check .
      continue-on-error: true  # Don't fail the build on formatting issues

    - name: Lint with ruff
      run: |
        ruff check .
      continue-on-error: true  # Don't fail the build on linting issues

    - name: Type check with mypy
      run: |
        mypy --install-types --non-interactive --ignore-missing-imports plexomatic
      continue-on-error: true  # Don't fail the build on type checking issues

    - name: Set up test environment
      run: |
        # Create directory for test output
        mkdir -p test_output

        # Ensure tests can be imported as a package
        touch tests/__init__.py

        # Add project root to PYTHONPATH
        echo "PYTHONPATH=$PYTHONPATH:$(pwd)" >> $GITHUB_ENV

    - name: Run single test directly
      run: |
        # Use a simple test file that's likely to work
        echo "Running a single test file directly:"
        python -m pytest tests/test_cli.py -v > test_output/single_test.log 2>&1 || echo "Single test failed, but continuing"
        cat test_output/single_test.log
      continue-on-error: true

    - name: Run pytest with detailed logging
      run: |
        # First collect only to debug test discovery
        echo "Running test collection phase..."
        python -m pytest --collect-only -v > test_output/collection.log 2>&1 || echo "Collection phase failed, see logs"
        cat test_output/collection.log

        # Run full test suite with maximum verbosity
        echo "Running full test suite..."
        python -m pytest -xvs \
          --no-header \
          --tb=native \
          --cov=plexomatic \
          --cov-report=xml \
          --log-cli-level=DEBUG \
          > test_output/pytest_output.log 2>&1 || echo "Tests failed, see logs"

        # Print test output summary
        echo "=== TEST OUTPUT SUMMARY ==="
        cat test_output/pytest_output.log || echo "No output log found"
        echo "=== END TEST OUTPUT SUMMARY ==="
      continue-on-error: true  # Allow failure to be reported but complete all steps

    - name: Upload test logs
      uses: actions/upload-artifact@v4
      with:
        name: test-logs-${{ matrix.python-version }}
        path: test_output/
        retention-days: 5

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        file: ./coverage.xml
        fail_ci_if_error: false  # Don't fail if coverage upload fails
